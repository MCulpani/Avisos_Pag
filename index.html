<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF → Excel (única aba) — Compilador</title>
  <style>
    body { font-family: Inter, Arial, sans-serif; background:#f7fafc; color:#0f172a; padding:24px; }
    .card { background:white; border-radius:12px; box-shadow:0 6px 18px rgba(15,23,42,0.06); padding:18px; max-width:980px; margin:0 auto }
    h1 { margin:0 0 8px 0; font-size:20px }
    p { margin:6px 0 12px 0; color:#475569 }
    input[type=file] { display:block; margin-bottom:12px }
    button { padding:10px 14px; border-radius:8px; border:0; background:#0ea5a4; color:white; cursor:pointer }
    button[disabled] { opacity:0.6; cursor:not-allowed }
    table { width:100%; border-collapse:collapse; margin-top:12px }
    th,td { text-align:left; padding:6px 8px; border-bottom:1px solid #eef2f7; font-size:13px }
    pre { background:#0b1220; color:#d1fae5; padding:12px; border-radius:8px; overflow:auto }
    .progress { margin-top:8px }
  </style>
</head>
<body>
  <div class="card">
    <h1>Compilar vários PDFs em um único Excel (uma aba)</h1>
    <p>Selecione vários arquivos PDF. O script tentará extrair linhas que começam com <code>5</code> (como no seu Power Query) e montar as colunas: <strong>Column1.1, Column1.2, Column2, Column3, Column4</strong>. Ao final será gerado um .xlsx com 1 aba.</p>

    <input id="files" type="file" accept="application/pdf" multiple />
    <div>
      <button id="processBtn">Processar e gerar Excel</button>
      <button id="downloadBtn" disabled>Baixar Excel</button>
    </div>
    <div class="progress" id="progress"></div>

    <div id="preview"></div>

    <h3>Logs</h3>
    <pre id="log">Pronto.</pre>
  </div>

  <!-- Dependências: pdf.js (Mozilla) e SheetJS (xlsx) via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
    // Configura worker do pdf.js (aponta para CDN)
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    const filesInput = document.getElementById('files');
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const logEl = document.getElementById('log');
    const progressEl = document.getElementById('progress');
    const previewEl = document.getElementById('preview');

    let compiledRows = [];
    let workbookBinary = null;

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      logEl.textContent = `[${now}] ${msg}\n` + logEl.textContent;
    }

    function parseCurrency(text) {
      if (!text) return null;
      // Remove currency symbols and whitespace
      let t = text.replace(/[R$\s]/g, '');
      // If contains both '.' and ',', assume '.' thousands and ',' decimals (pt-BR)
      if (t.indexOf('.') !== -1 && t.indexOf(',') !== -1) {
        t = t.replace(/\./g, '').replace(',', '.');
      } else {
        // if only comma present, treat comma as decimal
        if (t.indexOf(',') !== -1 && t.indexOf('.') === -1) t = t.replace(',', '.');
        // if only dots present and more than one, remove thousands separators
        if ((t.match(/\./g) || []).length > 1) t = t.replace(/\./g, '');
      }
      // remove any non-digit except dot and minus
      t = t.replace(/[^0-9.\-]/g, '');
      const v = parseFloat(t);
      return isNaN(v) ? null : v;
    }

    function parseDateToken(token) {
      // token examples: dd/mm/yyyy or yyyy-mm-dd or dd-mm-yyyy
      token = token.replace(/\./g,'-');
      const dmY = /^(\d{2})[\/\-](\d{2})[\/\-](\d{4})$/;
      const Ymd = /^(\d{4})[\-](\d{2})[\-](\d{2})$/;
      if (dmY.test(token)) {
        const m = token.match(dmY);
        return `${m[3]}-${m[2]}-${m[1]}`; // ISO yyyy-mm-dd
      }
      if (Ymd.test(token)) return token;
      return null;
    }

    async function extractTextFromPDF(arrayBuffer) {
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items.map(item => item.str);
        // join with spaces and add newline between pages so we can split lines
        fullText += strings.join(' ') + '\n';
      }
      return fullText;
    }

    function tryParseDataLines(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      const parsed = [];

      for (const line of lines) {
        // Quick filter: line must start with '5' (as in your M code)
        if (!line.startsWith('5')) continue;

        // Tokenize by whitespace
        const tokens = line.split(/\s+/);
        if (tokens.length < 4) continue; // too short

        // We'll assume the last two tokens are Column3 and Column4 (currencies),
        // the token before those is Column2 (date), and everything before is Column1 (composite)
        let col4 = tokens.pop();
        let col3 = tokens.pop();
        let maybeDate = tokens.pop();

        // If maybeDate doesn't look like a date, attempt to find a date token from the remaining tokens (search from end)
        if (!parseDateToken(maybeDate)) {
          let foundIndex = -1;
          for (let i = tokens.length - 1; i >= 0; i--) {
            if (parseDateToken(tokens[i])) { foundIndex = i; break; }
          }
          if (foundIndex >= 0) {
            maybeDate = tokens.splice(foundIndex, 1)[0];
          } else {
            // no date found — put token back and skip
            continue;
          }
        }

        const column2 = parseDateToken(maybeDate);
        const column3 = parseCurrency(col3);
        const column4 = parseCurrency(col4);
        const column1 = tokens.join(' ');

        // Split column1 into Column1.1 (number) and Column1.2 (rest) by first space
        const idxSpace = column1.indexOf(' ');
        let column1_1 = column1;
        let column1_2 = '';
        if (idxSpace > 0) {
          column1_1 = column1.substring(0, idxSpace);
          column1_2 = column1.substring(idxSpace + 1).trim();
        }

        // try to parse integer for Column1.1
        const column1_1_int = parseInt(column1_1.replace(/[^0-9\-]/g, ''));

        parsed.push({
          'Column1.1': isNaN(column1_1_int) ? column1_1 : column1_1_int,
          'Column1.2': column1_2,
          'Column2': column2,
          'Column3': column3,
          'Column4': column4,
          '__source_line': line
        });
      }

      return parsed;
    }

    async function processFiles(files) {
      compiledRows = [];
      progressEl.textContent = `Arquivos: ${files.length}`;
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        progressEl.textContent = `Processando ${i+1}/${files.length}: ${f.name}`;
        log(`Lendo ${f.name} (${f.size} bytes)`);
        try {
          const arrayBuffer = await f.arrayBuffer();
          const text = await extractTextFromPDF(arrayBuffer);
          const parsed = tryParseDataLines(text);
          log(`Encontradas ${parsed.length} linhas a partir de ${f.name}`);
          compiledRows.push(...parsed.map(r => ({...r, 'Nome da Origem': f.name})));
        } catch (err) {
          log(`Erro lendo ${f.name}: ${err.message || err}`);
        }
      }

      progressEl.textContent = `Concluído — linhas: ${compiledRows.length}`;
      return compiledRows;
    }

    function renderPreview(rows, max=50) {
      if (!rows || rows.length === 0) { previewEl.innerHTML = '<p>Nenhuma linha encontrada.</p>'; return; }
      const sample = rows.slice(0, max);
      let html = '<table><thead><tr>';
      const keys = Object.keys(sample[0]);
      // exclude internal source_line from header (but keep Nome da Origem)
      const headerKeys = keys.filter(k => k !== '__source_line');
      for (const k of headerKeys) html += `<th>${k}</th>`;
      html += '</tr></thead><tbody>';
      for (const r of sample) {
        html += '<tr>';
        for (const k of headerKeys) html += `<td>${r[k] !== null && r[k] !== undefined ? r[k] : ''}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table>';
      if (rows.length > max) html += `<p>Mostrando ${max} de ${rows.length} linhas.</p>`;
      previewEl.innerHTML = html;
    }

    function buildExcel(rows) {
      if (!rows || rows.length === 0) return null;
      // Remove internal helper fields before exporting
      const cleanRows = rows.map(r => ({
        'Nome da Origem': r['Nome da Origem'],
        'Column1.1': r['Column1.1'],
        'Column1.2': r['Column1.2'],
        'Column2': r['Column2'],
        'Column3': r['Column3'],
        'Column4': r['Column4']
      }));

      const ws = XLSX.utils.json_to_sheet(cleanRows, {dateNF: 'yyyy-mm-dd'});
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Dados');
      return wb;
    }

    processBtn.addEventListener('click', async () => {
      const files = Array.from(filesInput.files || []);
      if (files.length === 0) { alert('Selecione pelo menos um arquivo PDF.'); return; }
      processBtn.disabled = true;
      downloadBtn.disabled = true;
      compiledRows = [];
      log('Iniciando processamento...');
      try {
        await processFiles(files);
        renderPreview(compiledRows);
        if (compiledRows.length === 0) {
          log('Nenhuma linha foi extraída. Verifique o formato dos PDFs ou as regras de detecção.');
          alert('Nenhuma linha extraída. Veja o log.');
        } else {
          const wb = buildExcel(compiledRows);
          // store workbook and enable download
          workbookBinary = wb;
          downloadBtn.disabled = false;
          log('Excel pronto para download.');
        }
      } catch (err) {
        log('Erro: ' + (err.message || err));
      } finally {
        processBtn.disabled = false;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!workbookBinary) return;
      const filename = `compilado_${new Date().toISOString().slice(0,10)}.xlsx`;
      XLSX.writeFile(workbookBinary, filename);
      log('Arquivo gerado: ' + filename);
    });

  </script>
</body>
</html>
